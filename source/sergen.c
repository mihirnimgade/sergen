#include "c-vector/cvector.h"
#include "c-vector/cvector_utils.h"
#include "clang-c/Index.h"
#include <errno.h>
#include <getopt.h>
#include <limits.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

// LIMITATION: the user must provide header files in a specific order so that
// sergen is able to correctly generate serializable struct definitions and
// serialization implementations. This means that if sergen is provided a
// non-standalone header file (i.e., one that includes other header files) as a
// sole command-line argument, it will not be able to generate serialization
// code that compiles. This is because the provided header file in some way
// depends on another header file which sergen knows nothing about. That means
// it's the user's responsibility to not only provide all dependent header
// files but also to provide them in the correct order. Given a header file you
// want to generate serialization functions for (call it `user.h`), it is
// important to provide  the header files that `user.h` #includes BEFORE
// `user.h` itself. So if `user.h` #includes `parent1.h` and `parent2.h`, then
// your corresponding sergen command should be:
//
// `$ sergen parent1.h parent2.h user.h`
//
// Note that if `parent1.h` and `parent2.h` themselves include other header
// files, these included header files must occur before `parent1.h` and
// `parent2.h`. This happens recursively until you reach a standalone set of
// header files at the beginning of your `sergen` command.

#define MAX_NAMESPACE_LEN                (64)
#define MAX_ARRAY_DECLARATION_SIZE_CHARS (256)

/* Max serializable integer size is 64-bits (8 bytes) */
#define MAX_SERIALIZABLE_INTEGRAL_SIZE (8)

enum CXChildVisitResult base_visitor(CXCursor current_cursor, CXCursor parent_cursor, CXClientData client);
enum CXChildVisitResult typedef_visitor(CXCursor current_cursor, CXCursor parent_cursor, CXClientData client);
enum CXVisitorResult    field_visitor(CXCursor current_cursor, CXClientData client);
enum CXChildVisitResult enum_field_visitor(CXCursor current_cursor, CXCursor parent_cursor, CXClientData client);
enum CXChildVisitResult field_annotation_visitor(CXCursor current_cursor, CXCursor parent_cursor, CXClientData client);
enum CXChildVisitResult struct_packed_visitor(CXCursor current_cursor, CXCursor parent_cursor, CXClientData client);

enum CXChildVisitResult stage_two_base_visitor(CXCursor current_cursor, CXCursor parent_cursor, CXClientData client);
enum CXVisitorResult    stage_two_field_visitor(CXCursor current_cursor, CXClientData client);

void generate_header_file(CXTranslationUnit unit, const char *namespace);
void generate_ferry_source(FILE *fhand, const char *namespace);
void generate_pack_source(const char *header_file_path, const char *namespace);
void generate_desired_includes(FILE *fh, cvector_vector_type(char *) header_files, cvector_vector_type(char *) include_directories);

char *generate_serializable_field_accessor(cvector_vector_type(const char *) field_ref);
char *generate_native_field_accessor(cvector_vector_type(const char *) field_ref);

void char_ptr_destructor(void *buf);

bool check_internal_typedef(CXType td_type);
bool check_typedef_start(CXType td_type, const char *start);
bool check_user_typedef(CXType td_type);
bool check_derived_type(CXType td_type);
bool find_in_vector(cvector_vector_type(int) vec, int item);
bool is_integral_type(CXType type);

static const char *header_template =
    "/*\n"
    "* This header file was generated by `sergen.c` on %s. DO NOT EDIT!\n\n"
    "* Copyright 2024 Astera Labs, Inc. or its affiliates. All Rights Reserved.\n"
    "*\n"
    "* Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n"
    "* use this file except in compliance with the License. You may obtain a copy\n"
    "* of the License at:\n"
    "*\n"
    "*   http://www.apache.org/licenses/LICENSE-2.0\n"
    "*\n"
    "* or in the \"license\" file accompanying this file. This file is distributed\n"
    "* on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n"
    "* express or implied. See the License for the specific language governing\n"
    "* permissions and limitations under the License.\n"
    "*\n"
    "*/\n\n";

static const char *source_template =
    "/*\n"
    "* This source file was generated by `sergen.c` on %s. DO NOT EDIT!\n\n"
    "* Copyright 2024 Astera Labs, Inc. or its affiliates. All Rights Reserved.\n"
    "*\n"
    "* Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n"
    "* use this file except in compliance with the License. You may obtain a copy\n"
    "* of the License at:\n"
    "*\n"
    "*   http://www.apache.org/licenses/LICENSE-2.0\n"
    "*\n"
    "* or in the \"license\" file accompanying this file. This file is distributed\n"
    "* on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n"
    "* express or implied. See the License for the specific language governing\n"
    "* permissions and limitations under the License.\n"
    "*\n"
    "*/\n\n";

static const char *required_header_includes =
    "#include <stdint.h>\n"
    "#include <string.h>\n"
    "#include <stdbool.h>\n"
    "#include \"jansson/jansson.h\"\n\n";

// WARNING: As of 2025-05-19, there are numerous memory leaks in this program's
// implementation. Since it only runs once and doesn't have a long lifetime,
// the additional effort to free memory correctly will be kicked down the road.
// Until then, we'll let the operating system take care of memory cleanup for
// us :)
// TODO: write documentation for everything
// TODO: auto-generate documentation for ferry functions
// TODO: add ability to read custom annotation for char arrays to allow
// interpreting them as strings
// TODO: make sergen discern between user types and imported types using
// linkage. User types have a `CXLinkageKind` of `CXLinkage_External` (4) while
// imported types have a linkage of `CXLinkage_NoLinkage` (1)
// TODO: generate serialization functions for all possible enum values

// Perhaps when we find a type, we can find out the header file that type came
// from and add it to the header file list. Then, we can generate definitions
// for that header file later on. The issue with this is that sometimes we
// might generate definitions AFTER they are used in a preceding struct.
//
// If we encounter a struct definition that isn't in our translation unit, then
// we need to recurse into that translation unit and generate definitions for
// it.
//
// What if we encounter a translation unit for which we've already generated
// definitions for? How do we ensure duplicate definitions are not generated?
//
// IMPLEMENTATION: visitors are used to gather relevant data about the parsed
// data types. We store this in our own data structures and then these data
// structures are used to generate the JSON serialization code.

typedef struct
{
    const char *name;
    int         id;
} ParsedEnumField;

typedef struct
{
    const char *name;
    cvector_vector_type(ParsedEnumField) enum_field_vector;
} ParsedEnum;

typedef struct
{
    const char *name;
    CXType      type;
    bool        complex_type;
    bool        from_anonymous;
    cvector_vector_type(const char *) field_ref;
} ParsedStructField;

typedef struct
{
    const char *name;
    bool        packed;
    cvector_vector_type(ParsedStructField) field_vector;
} ParsedStruct;

typedef struct
{
    ParsedStruct *pstruct;
    bool          is_anonymous;
    const char *namespace;
    cvector_vector_type(const char *) field_ref;
} FieldVisitorData;

typedef struct
{
    ParsedEnum parsed_enum;
    bool       annotated;
} EnumFieldVisitorData;

static FILE *hfile_hand;
static FILE *sfile_hand;

// create relevant global dynamic vectors
static cvector_vector_type(CXCursor) enum_list              = NULL;
static cvector_vector_type(CXCursor) record_list            = NULL;
static cvector_vector_type(CXCursor) typedef_list           = NULL;
static cvector_vector_type(ParsedStruct) parsed_struct_list = NULL;
static cvector_vector_type(ParsedEnum) parsed_enum_list     = NULL;

static const char *include_option = "-I";

static CXIndex libclang_index;

void elem_destructor(void *buf)
{
    if (buf)
    {
        free(*(char **)buf);
    }
}

void generate_desired_includes(FILE *fh, cvector_vector_type(char *) header_files, cvector_vector_type(char *) include_directories)
{
    char path_buffer[PATH_MAX] = {0};

    // step 1: resolve all paths into full paths
    cvector_vector_type(char *) resolved_header_files        = NULL;
    cvector_vector_type(char *) resolved_include_directories = NULL;

    cvector_vector_type(char *) generated_includes = NULL;

    char **it = NULL;
    cvector_for_each_in(it, header_files)
    {
        if (realpath(*it, path_buffer) == NULL)
        {
            printf("[SERGEN]: could not canonicalize path: %s\n", *it);
            exit(2);
        }

        // allocate space for the resolved path and place into the vector
        size_t resolved_path_len = strlen(path_buffer);
        char  *resolved_path     = calloc(resolved_path_len + 1, sizeof(char));
        snprintf(resolved_path, resolved_path_len + 1, "%s", path_buffer);
        cvector_push_back(resolved_header_files, resolved_path);
    }

    it = NULL;
    cvector_for_each_in(it, include_directories)
    {
        if (realpath(*it, path_buffer) == NULL)
        {
            printf("[SERGEN]: could not canonicalize path: %s\n", *it);
            exit(2);
        }

        // allocate space for the resolved path and place into the vector
        size_t resolved_path_len = strlen(path_buffer);
        char  *resolved_path     = calloc(resolved_path_len + 1, sizeof(char));
        snprintf(resolved_path, resolved_path_len + 1, "%s", path_buffer);
        cvector_push_back(resolved_include_directories, resolved_path);
    }

    // step 2: for each header file path, determine the largest include
    // directory that occurs at the beginning of the header file path
    it        = NULL;
    int index = 0;
    cvector_for_each_in(it, resolved_header_files)
    {
        char *cur_header_file = *it;

        int   largest                   = 0;
        char *matched_include_directory = NULL;

        char **jt = NULL;
        cvector_for_each_in(jt, resolved_include_directories)
        {
            char *cur_include_dir = *jt;
            int   include_dir_len = strlen(cur_include_dir);
            int   result          = strncmp(cur_header_file, cur_include_dir, include_dir_len);
            /* If the include directory matched with the beginning of the
             * header file path AND it is the biggest include directory we've
             * matched so far, record it. */
            if (result == 0 && include_dir_len >= largest)
            {
                largest                   = include_dir_len;
                matched_include_directory = cur_include_dir;
            }
        }

        /* Now we know the largest include directory that matched our header
         * file. Remove that from the header file path and write it to the file
         * handle. */
        char *shortened_header_file_path = NULL;

        // ASSUMPTION: the `cvector_for_each_in` macro iterates over the
        // elements in the same order every time
        /* If we didn't find a matching include directory, then use the
         * UNRESOLVED header file path directly. Realistically, we shouldn't
         * ever reach here. */
        if (largest == 0 || matched_include_directory == NULL)
        {
            shortened_header_file_path = header_files[index];
        }
        else
        {
            shortened_header_file_path = cur_header_file + largest + 1;
        }

        // step 4: write the amended header file path plus the include directive
        // into the file handle
        fprintf(fh, "#include \"%s\"\n", shortened_header_file_path);
        index++;
    }

    fprintf(fh, "\n");
    fflush(fh);

    // step 5: free associated memory
}

int main(int argc, char **argv)
{
    int output_header_name_provided = false;
    int output_source_name_provided = false;
    int namespace_provided          = false;

    char output_header_name[PATH_MAX] = {0};
    char output_source_name[PATH_MAX] = {0};
    char namespace[MAX_NAMESPACE_LEN] = {0};

    cvector_vector_type(char *) include_directories = NULL;
    cvector_init(include_directories, 16, elem_destructor);

    /* parse arguments */
    int c = -1;
    while (1)
    {
        static struct option sergen_options[] = {
            {"output-header", required_argument, NULL, 'H'},
            {"output-source", required_argument, NULL, 'S'},
            {"include-dir",   required_argument, NULL, 'I'},
            {"namespace",     required_argument, NULL, 'n'},
            {0,               0,                 0,    0  }
        };

        int opt_index = 0;
        c             = getopt_long(argc, argv, "H:S:I:n:", sergen_options, &opt_index);

        if (c == -1)
        {
            break;
        }

        switch (c)
        {
            case 'S':
                snprintf(output_source_name, PATH_MAX, "%s", optarg);
                output_source_name_provided = true;
                break;
            case 'H':
                snprintf(output_header_name, PATH_MAX, "%s", optarg);
                output_header_name_provided = true;
                break;
            case 'I':
                (void)0;
                int optarg_len = strlen(optarg);
                // allocate space for the include directory path string
                char *buf = (char *)calloc(optarg_len + 1, sizeof(char));
                snprintf(buf, optarg_len + 1, "%s", optarg);
                cvector_push_back(include_directories, buf);
                break;
            case 'n':
                // store namespace
                snprintf(namespace, MAX_NAMESPACE_LEN, "%s", optarg);
                namespace_provided = true;
                break;
            case '?':
                break;
            default:
                break;
        }
    }

    /* make sure that both a header name and source name were provided */
    if (!output_header_name_provided)
    {
        printf("Please provide an output header file name using --output-header or -H!\n");
        exit(1);
    }
    if (!output_source_name_provided)
    {
        printf("Please provide an output source file name using --output-source or -S!\n");
        exit(1);
    }
    if (!namespace_provided)
    {
        printf("Please provide a namespace using --namespace or -n!\n");
        exit(1);
    }

    // open header file for write
    hfile_hand = fopen(output_header_name, "w");
    if (hfile_hand == NULL)
    {
        printf("Unable to open file: \"%s\", errno=%d\n: %s", output_header_name, errno, strerror(errno));
        exit(1);
    }

    // open source file for write
    sfile_hand = fopen(output_source_name, "w");
    if (sfile_hand == NULL)
    {
        printf("Unable to open file: \"%s\", errno=%d\n: %s", output_source_name, errno, strerror(errno));
        exit(1);
    }

    // generate the current time and format into string
    time_t     now    = time(NULL);
    struct tm *now_tm = localtime(&now);

    char formatted_tm[64];

    strftime(formatted_tm, sizeof formatted_tm, "%c", now_tm);

    // insert the banner text for the header file
    fprintf(hfile_hand, header_template, formatted_tm);

    // insert the banner text for the source file
    fprintf(sfile_hand, source_template, formatted_tm);

    // insert the required includes
    fputs(required_header_includes, hfile_hand);

    // insert other required includes
    cvector_vector_type(char *) header_files = NULL;
    for (int i = optind; i < argc; i++)
    {
        // No need to malloc here since the header files appear towards the end
        // of argv and we're not worried about `getopt_long` moving things
        // around. So we can add pointers to argv straight into the cvector.
        cvector_push_back(header_files, argv[i]);
    }
    generate_desired_includes(hfile_hand, header_files, include_directories);

    {
        cvector_vector_type(char *) output_header_files = NULL;
        cvector_push_back(output_header_files, output_header_name);
        generate_desired_includes(sfile_hand, output_header_files, include_directories);
    }

    // insert the JsonPackResult_e type
    fprintf(hfile_hand, "typedef enum\n");
    fprintf(hfile_hand, "{\n");
    fprintf(hfile_hand, "    PACK_SUCCESS = 0,\n");
    fprintf(hfile_hand, "    PACK_UNEXECUTED = -1,\n");
    fprintf(hfile_hand, "    PACK_ERROR = -2,\n");
    fprintf(hfile_hand, "} JsonPackResult_e;\n\n");

    libclang_index = clang_createIndex(0, 0);

    /* look at arguments past `optind` to get the list of provided header files */
    int         cur_file_idx  = optind;
    const char *cur_file_name = argv[cur_file_idx];

    /* Generate the command-line arguments to pass to
     * `clang_parseTranslationUnit2` so that it parses the header files
     * correctly */
    cvector_vector_type(const char *) parse_argv = NULL;
    char **dir_ptr                               = NULL;
    cvector_for_each_in(dir_ptr, include_directories)
    {
        cvector_push_back(parse_argv, include_option);
        cvector_push_back(parse_argv, *dir_ptr);
    }

    size_t parse_argv_size = cvector_size(parse_argv);

    int index = 0;
    // STAGE 1 GENERATION: generates the serialization header file along with
    // the source code for the ferry functions
    while (cur_file_name != NULL)
    {
        printf("[ %d ] Generating serialization functions for header file: %s\n", index, cur_file_name);
        // check if the provided file name is readable
        int access_rc = access(cur_file_name, R_OK);

        if (access_rc)
        {
            printf("[SERGEN]: WARNING header file %s is unreadable\n", cur_file_name);
            exit(1);
        }

        // parse the provided file into its AST
        CXTranslationUnit unit;
        enum CXErrorCode  rc = clang_parseTranslationUnit2(libclang_index, cur_file_name, parse_argv, parse_argv_size, NULL, 0, CXTranslationUnit_None, &unit);
        if (rc != CXError_Success)
        {
            printf("[SERGEN]: unable to parse following header file: %s\n", cur_file_name);
            continue;
        }

        generate_header_file(unit, namespace);
        generate_ferry_source(sfile_hand, namespace);

        // clear the global lists so we can use it in the second stage
        cvector_clear(typedef_list);
        cvector_clear(enum_list);
        cvector_clear(record_list);
        cvector_clear(parsed_struct_list);
        cvector_clear(parsed_enum_list);

        clang_suspendTranslationUnit(unit);
        clang_disposeTranslationUnit(unit);

        // WARNING: need to flush changes BEFORE generating pack source since
        // without it, the changes don't get flushed to the generated header
        // file before the `generate_pack_source` function reads it
        fflush(hfile_hand);
        fflush(sfile_hand);

        cur_file_name = argv[++cur_file_idx];
        index++;
    }

    printf("[SERGEN]: successfully generated serializer header file %s\n", output_header_name);

    // STAGE 2 GENERATION: generates the pack functions using the generated header file from stage 1.
    // This need only be done once since we only generated a single header file `serializer.h` from stage 1.

    generate_pack_source(output_header_name, namespace);

    printf("[SERGEN]: successfully generated serializer source file %s\n", output_source_name);

    fclose(sfile_hand);
    fclose(hfile_hand);
    cvector_free(include_directories);

    clang_disposeIndex(libclang_index);

    return 0;
}

enum CXChildVisitResult field_annotation_visitor(CXCursor current_cursor, CXCursor parent_cursor, CXClientData client)
{
    const char *annotation_str;

    // NOTE: we're assuming that the `AnnotateAttr` node in the Clang AST is a
    // direct descendant of the `FieldDecl` node that is being annotated.
    if (parent_cursor.kind == CXCursor_FieldDecl && current_cursor.kind == CXCursor_AnnotateAttr)
    {
        annotation_str = clang_getCString(clang_getCursorSpelling(current_cursor));

        if (!strcmp(annotation_str, "sergen_skip"))
        {
            *((bool *)client) = true;
        }
        else
        {
            *((bool *)client) = false;
        }

        return CXChildVisit_Break;
    }

    return CXChildVisit_Continue;
}

enum CXChildVisitResult struct_packed_visitor(CXCursor current_cursor, CXCursor parent_cursor, CXClientData client)
{
    // The parent of a PackedAttr node is a StructDecl node.

    // NOTE: we're assuming that the `PackedAttr` node in the Clang AST is a
    // direct descendant of the `StructDecl` node that is being annotated.
    if (parent_cursor.kind == CXCursor_StructDecl && current_cursor.kind == CXCursor_PackedAttr)
    {
        *((bool *)client) = true;
        return CXChildVisit_Break;
    }
    else
    {
        *((bool *)client) = false;
    }

    return CXChildVisit_Continue;
}

// Visits the fields of a Record type
enum CXVisitorResult field_visitor(CXCursor current_cursor, CXClientData client)
{
    // NOTE: cannot really remove writing to a file from this function because
    // it's not easy to correctly represent recursive structs in a data
    // structure. Until that's figured out, stick with the mixed
    // implementation.

    // this function is meant to iterate over a `CXType` object with kind `CXType_Record`
    CXType cursor_type = clang_getCursorType(current_cursor);

    CXString    name_spelling      = clang_getCursorSpelling(current_cursor);
    const char *name_spelling_cstr = clang_getCString(name_spelling);

    CXString    cursor_type_spelling = clang_getTypeSpelling(cursor_type);
    const char *cursor_type_cstr     = clang_getCString(cursor_type_spelling);

    // reinterpret the client pointer
    FieldVisitorData *inner_client = (FieldVisitorData *)(client);

    // check if the field is annotated with anything
    bool annotated = false;
    clang_visitChildren(current_cursor, field_annotation_visitor, (CXClientData)(&annotated));

    // temporarily place the leaf field name into the field reference vector
    // so that we generate the correct accessor
    cvector_push_back(inner_client->field_ref, name_spelling_cstr);
    char *serializable_accessor = generate_serializable_field_accessor(inner_client->field_ref);
    cvector_pop_back(inner_client->field_ref);

    const char *namespace = inner_client->namespace;

    if (annotated)
    {
        goto return_block;
    }

    switch (cursor_type.kind)
    {
        case CXType_ConstantArray:
            {
                CXType nested_type = {0};

                char array_decl[MAX_ARRAY_DECLARATION_SIZE_CHARS] = {0};
                int  array_decl_idx                               = 0;
                int  remaining_space                              = MAX_ARRAY_DECLARATION_SIZE_CHARS - array_decl_idx;

                /* Get the element numbers of the initial array and write to
                 * the array declaration buffer */
                int element_num = clang_getArraySize(cursor_type);
                array_decl_idx += snprintf(array_decl + array_decl_idx, remaining_space, "[%d]", element_num);

                CXType element_type = clang_getElementType(cursor_type);
                while (element_type.kind == CXType_ConstantArray)
                {
                    /* Remaining space check */
                    int remaining_space = MAX_ARRAY_DECLARATION_SIZE_CHARS - array_decl_idx;
                    if (remaining_space <= 0)
                    {
                        printf("[SERGEN]: Array declaration buffer is not big enough! Please allocate more space.\n");
                    }

                    element_num = clang_getArraySize(element_type);

                    /* Append to the array declaration string and increment the
                     * index by the number of characters printed */
                    array_decl_idx += snprintf(array_decl + array_decl_idx, remaining_space, "[%d]", element_num);

                    /* Get the next nested element type */
                    element_type = clang_getElementType(element_type);
                };

                CXCursor    element_cursor    = clang_getTypeDeclaration(element_type);
                const char *element_type_cstr = clang_getCString(clang_getTypeSpelling(element_type));

                /* If we've reached here then `element_type` contains the base
                 * type of the array (i.e., the type that is actually contained
                 * within the array) */

                /* Case 1: array of a typedef'd type */
                if (element_type.kind == CXType_Typedef)
                {
                    if (check_user_typedef(element_type) && check_derived_type(element_type))
                    {
                        fprintf(hfile_hand, "    %s__Serializable%s %s%s;\n", namespace, element_type_cstr, serializable_accessor, array_decl);
                    }
                    else if (!check_user_typedef(element_type) && check_derived_type(element_type))
                    {
                        fprintf(hfile_hand, "    // WARNING: unable to create field for derived type defined in system header\n");
                    }
                    else
                    {
                        fprintf(hfile_hand, "    %s %s%s;\n", element_type_cstr, serializable_accessor, array_decl);
                    }
                }
                /* Case 2: array of an anonymous type */
                else if (clang_Cursor_isAnonymous(element_cursor))
                {
                    fprintf(hfile_hand, "    // WARNING: constant arrays of anonymous structs are not supported yet\n");
                    goto return_block;
                }
                /* Case 3: array of all other types */
                else
                {
                    fprintf(hfile_hand, "    %s %s%s;\n", element_type_cstr, serializable_accessor, array_decl);
                }

                goto add_to_field_vec;
            }
        case CXType_Typedef:
            {
                CXType      canon_type        = clang_getCanonicalType(cursor_type);
                const char *element_type_cstr = clang_getCString(clang_getTypeSpelling(cursor_type));

                // if the typedef is defined in the current file, then we know we
                // have a serializable version of it
                if (check_user_typedef(cursor_type))
                {
                    // if the typedef's canonical type isn't a record or an
                    // enum, then we cannot serialize it
                    if (canon_type.kind == CXType_Record || canon_type.kind == CXType_Enum)
                    {
                        fprintf(hfile_hand, "    %s__Serializable%s %s;\n", namespace, cursor_type_cstr, serializable_accessor);
                    }
                    else
                    {
                        fprintf(hfile_hand, "    // WARNING: unable to serializer field: %s %s\n", cursor_type_cstr, serializable_accessor);
                        goto return_block;
                    }
                }
                else
                {
                    // Check whether we have a typedef'd struct or a typedef'd
                    // enum that could be defined in the current header file or
                    // another header file in the include path given to clang.
                    // For now, we're assuming that the user provides the
                    // necessary header files in the correct order, to allow
                    // for serialization of struct definitions with fields of
                    // foreign types.
                    if (canon_type.kind == CXType_Record || canon_type.kind == CXType_Enum)
                    {
                        CXCursor         curs = clang_getTypeDeclaration(canon_type);
                        CXSourceLocation loc  = clang_getCursorLocation(curs);

                        // if the type is in a system header, we safely assume
                        // that we don't know how to serialize it
                        if (clang_Location_isInSystemHeader(loc))
                        {
                            fprintf(hfile_hand, "    // WARNING: unable to serialize field %s %s\n", element_type_cstr, serializable_accessor);
                        }
                        else
                        {
                            fprintf(hfile_hand, "    %s__Serializable%s %s;\n", namespace, cursor_type_cstr, serializable_accessor);
                        }
                    }
                    else
                    {
                        fprintf(hfile_hand, "    %s %s;\n", element_type_cstr, serializable_accessor);
                    }
                }
                goto add_to_field_vec;
            }
        case CXType_Pointer:
            {
                // if it is a regular pointer, then goto default but if it points to a typedef then something else...
                CXType pointee_type = clang_getPointeeType(cursor_type);

                // TODO: expand this later to include more types
                // only pass through pointers that don't point to structs or functions
                if (pointee_type.kind != CXType_Typedef && pointee_type.kind != CXType_FunctionProto && pointee_type.kind != CXType_FunctionNoProto)
                {
                    fprintf(hfile_hand, "    %s %s;\n", cursor_type_cstr, serializable_accessor);
                    goto add_to_field_vec;
                }
                goto return_block;
            }
        // we get here when we have a struct field that is an anonymous struct without a field name
        case CXType_Record:
            {
                // the recursion is simpler here since when an anonymous struct
                // doesn't have a field name, it basically might as well not
                // exist since field accesses happen exactly the same as if the
                // anonymous struct wasn't there
                clang_Type_visitFields(cursor_type, field_visitor, client);
                goto return_block;
            }
        // we get here when we have a struct field that is an anonymous struct WITH a field name
        case CXType_Elaborated:
            {
                // the field reference vector keeps track of our recursion
                // depth and allows us to flatten nested anonymous struct
                // fields into a single level
                cvector_push_back(inner_client->field_ref, name_spelling_cstr);
                clang_Type_visitFields(cursor_type, field_visitor, client);
                cvector_pop_back(inner_client->field_ref);
                goto return_block;
            }
        default:
            {
                fprintf(hfile_hand, "    %s %s;\n", cursor_type_cstr, serializable_accessor);

                goto add_to_field_vec;
            }
    }

add_to_field_vec:
    if (client != NULL)
    {
        ParsedStructField parsed_field = {.name = name_spelling_cstr, .type = cursor_type, .complex_type = false, .from_anonymous = inner_client->is_anonymous, .field_ref = NULL};
        cvector_copy(inner_client->field_ref, parsed_field.field_ref);
        cvector_push_back(parsed_field.field_ref, name_spelling_cstr);
        cvector_push_back(inner_client->pstruct->field_vector, parsed_field);
    }

return_block:
    free(serializable_accessor);
    return CXVisit_Continue;
}

enum CXChildVisitResult base_visitor(CXCursor current_cursor, CXCursor parent_cursor, CXClientData client)
{
    CXType cursor_type        = clang_getCursorType(current_cursor);
    CXType parent_cursor_type = clang_getCursorType(parent_cursor);

    enum CXCursorKind cursor_kind = clang_getCursorKind(current_cursor);

    CXString type_kind       = clang_getTypeKindSpelling(cursor_type.kind);
    CXString type_spelling   = clang_getTypeSpelling(cursor_type);
    CXString cursor_spelling = clang_getCursorKindSpelling(cursor_kind);

    CXString parent_type_spelling = clang_getTypeSpelling(parent_cursor_type);

    const char *cursor_spelling_cstr = clang_getCString(cursor_spelling);
    const char *parent_type_cstr     = clang_getCString(parent_type_spelling);
    const char *type_spelling_cstr   = clang_getCString(type_spelling);

    // record typedef declaration cursors
    if (current_cursor.kind == CXCursor_TypedefDecl)
    {
        // filter out all types that are external to the main file of the current translation unit
        if (!check_internal_typedef(cursor_type))
        {
            return CXChildVisit_Continue;
        }

        // add the typedef cursor to the overall typedef list
        cvector_push_back(typedef_list, current_cursor);

        CXType canonical_type = clang_getCanonicalType(cursor_type);

        if (canonical_type.kind == CXType_Enum)
        {
            // add the typedef cursor to the enum list
            cvector_push_back(enum_list, current_cursor);
        }
        else if (canonical_type.kind == CXType_Record)
        {
            // add the typedef cursor to the record list
            cvector_push_back(record_list, current_cursor);
        }
        else
        {
            printf("WARNING: sergen unable to generate definition for typedef: %s %s\n", type_spelling_cstr, cursor_spelling_cstr);
        }

        return CXChildVisit_Continue;
    }

    return CXChildVisit_Recurse;
}

// Visits the fields in a typedef'd enum
// We have the cursor to the typedef that defines the enum. Now, we need to iterate over
// it and fill out a `ParsedEnum` type.
enum CXChildVisitResult enum_field_visitor(CXCursor current_cursor, CXCursor parent_cursor, CXClientData client)
{
    /* Reinterpret cast the client data */
    EnumFieldVisitorData *visitor_data = (EnumFieldVisitorData *)(client);

    const char *annotation_str = NULL;

    /* NOTE: we're assuming that the `AnnotateAttr` node in the Clang AST is a
     * direct descendant of the `EnumDecl` node that is being annotated as
     * shown in the AST snippet below:
     *
     * |-EnumDecl 0x25902a0 <line:47:9, line:84:1> line:47:14 AriesLinkStateEnum
     * | |-AnnotateAttr 0x25919e8 <./libs/umami-cli/args.h:47:36, col:58> "sergen_skip"
     */

    if (parent_cursor.kind == CXCursor_EnumDecl && current_cursor.kind == CXCursor_AnnotateAttr)
    {
        annotation_str          = clang_getCString(clang_getCursorSpelling(current_cursor));
        visitor_data->annotated = strcmp(annotation_str, "sergen_skip") == 0 ? true : false;
    }

    if (current_cursor.kind == CXCursor_EnumConstantDecl && visitor_data->parsed_enum.name != NULL)
    {
        const char     *enum_const_name = clang_getCString(clang_getCursorSpelling(current_cursor));
        int             id              = clang_getEnumConstantDeclValue(current_cursor);
        ParsedEnumField field           = {.name = enum_const_name, .id = id};
        cvector_push_back(visitor_data->parsed_enum.enum_field_vector, field);
        return CXChildVisit_Recurse;
    }

    return CXChildVisit_Recurse;
}

enum CXChildVisitResult stage_two_base_visitor(CXCursor current_cursor, CXCursor parent_cursor, CXClientData client)
{
    CXType cursor_type        = clang_getCursorType(current_cursor);
    CXType parent_cursor_type = clang_getCursorType(parent_cursor);

    enum CXCursorKind cursor_kind = clang_getCursorKind(current_cursor);

    CXString type_kind       = clang_getTypeKindSpelling(cursor_type.kind);
    CXString type_spelling   = clang_getTypeSpelling(cursor_type);
    CXString cursor_spelling = clang_getCursorKindSpelling(cursor_kind);

    CXString parent_type_spelling = clang_getTypeSpelling(parent_cursor_type);

    const char *parent_type_cstr   = clang_getCString(parent_type_spelling);
    const char *type_spelling_cstr = clang_getCString(type_spelling);

    CXString           current_cursor_cx   = clang_getCursorSpelling(current_cursor);
    const char        *current_cursor_cstr = clang_getCString(current_cursor_cx);
    enum CXLinkageKind cc_linkage          = clang_getCursorLinkage(current_cursor);

    const char *namespace = (const char *)client;

    // record typedef declaration cursors
    if (current_cursor.kind == CXCursor_TypedefDecl)
    {
        clang_disposeString(current_cursor_cx);

        // filter out all types that don't start with "Serializable"
        char buf[128] = {0};
        snprintf(buf, 128, "%s__Serializable", namespace);
        if (!check_typedef_start(cursor_type, buf))
        {
            return CXChildVisit_Continue;
        }

        // add the typedef cursor to the overall typedef list
        cvector_push_back(typedef_list, current_cursor);

        CXType canonical_type = clang_getCanonicalType(cursor_type);

        // NOTE: in stage two generation, there is no need to keep track of enums
        if (canonical_type.kind == CXType_Enum)
        {
            // add the typedef cursor to the enum list
            cvector_push_back(enum_list, current_cursor);
        }
        else if (canonical_type.kind == CXType_Record)
        {
            // add the typedef cursor to the record list
            cvector_push_back(record_list, current_cursor);
            const char *current_cursor_cstr = clang_getCString(clang_getCursorSpelling(current_cursor));
        }
        else
        {
            printf("WARNING: sergen unable to generate definition for typedef: %s\n", type_spelling_cstr);
        }

        return CXChildVisit_Continue;
    }

    return CXChildVisit_Recurse;
}

enum CXVisitorResult stage_two_field_visitor(CXCursor current_cursor, CXClientData client)
{
    // this function is meant to iterate over a `CXType` object with kind `CXType_Record`
    CXType cursor_type = clang_getCursorType(current_cursor);

    CXString    name_spelling      = clang_getCursorSpelling(current_cursor);
    const char *name_spelling_cstr = clang_getCString(name_spelling);

    CXString    cursor_type_spelling = clang_getTypeSpelling(cursor_type);
    const char *cursor_type_cstr     = clang_getCString(cursor_type_spelling);

    if (client != NULL)
    {
        ParsedStructField parsed_field = {.name = name_spelling_cstr, .type = cursor_type};
        cvector_push_back(((ParsedStruct *)client)->field_vector, parsed_field);
    }

    return CXVisit_Continue;
}

/**
 * @brief Checks whether a typedef is defined in the main file of its
 * translation unit.
 *
 * @param[in] td_type - Clang `CXType` object representing the relevant typedef.
 * @returns - 0 if the typedef is defined outside the main file and 1 if the
 * typedef is defined inside the main file of its translation unit.
 */
bool check_internal_typedef(CXType td_type)
{
    CXCursor         type_cursor   = clang_getTypeDeclaration(td_type);
    CXSourceLocation type_location = clang_getCursorLocation(type_cursor);
    return clang_Location_isFromMainFile(type_location);
}

/**
 * @brief Checks if the provided type is defined in a user header file or a
 * system header.
 *
 * @param[in] td_type - Clang `CXType` object representing the relevant typedef.
 * @returns - 0 if the type is defined in a system header and 1 if the type is
 * defined in a user header.
 */
bool check_user_typedef(CXType td_type)
{
    CXCursor         type_cursor   = clang_getTypeDeclaration(td_type);
    CXSourceLocation type_location = clang_getCursorLocation(type_cursor);
    return !clang_Location_isInSystemHeader(type_location);
}

/**
 * @brief Checks if the provided type is a typedef for a derived type (struct,
 * enum, or union).
 *
 * @param[in] td_type - Clang `CXType` object representing the relevant typedef.
 * @returns - 0 if the canonical type of the typedef is a base type and 1 if it
 * is a derived type.
 */
bool check_derived_type(CXType td_type)
{
    CXType canon_type = clang_getCanonicalType(td_type);
    return (canon_type.kind == CXType_Record || canon_type.kind == CXType_Enum);
}

/**
 * @brief Checks the name of a given typedef to check if it's name starts with a given string.
 *
 * @param[in] td_type - Clang `CXType` object representing the relevant typedef.
 * @param[in] start - pointer to starting string to check typedef name against.
 * @returns - 0 if the typedef name doesn't start with `start` and 1 if the
 * typedef name does start with `start`.
 */
bool check_typedef_start(CXType td_type, const char *start)
{
    const char *type_spelling_cstr = clang_getCString(clang_getTypeSpelling(td_type));
    return (strncmp(type_spelling_cstr, start, strlen(start)) == 0);
}

/**
 * @brief Checks if the given type is anonymous.
 *
 * @param[in] td_type - Clang `CXType` object representing the relevant type.
 * @returns - `false` if the type has a name and `true` if the type is anonymous.
 */
bool check_anonymous_type(ParsedStructField field)
{
    return !strcmp(field.name, "");
}

CXType get_const_array_base_type(CXType array_type)
{
    // PRECONDITION: CXTypeKind of `array_type` must be `CXType_ConstantArray`

    long long array_dims = 0;
    long long array_len  = 1;

    CXType    base_field_type = array_type;
    long long base_field_num  = 0;

    do
    {
        base_field_type = clang_getElementType(base_field_type);
        base_field_num  = clang_getNumElements(base_field_type);
        array_dims++;
        array_len *= base_field_num;
    } while (base_field_type.kind == CXType_ConstantArray);

    return base_field_type;
}

char *generate_serializable_field_accessor(cvector_vector_type(const char *) field_ref)
{
    // find out how long the total array is in terms of characters
    // so we can allocate a buffer that is big enough
    size_t char_count = 0;
    for (size_t i = 0; i < cvector_size(field_ref); i++)
    {
        const char *cur_name = field_ref[i];
        char_count += strlen(cur_name);
    }

    // allocate a buffer twice that big
    char *buf = (char *)malloc(char_count * 2);
    memset(buf, 0, (char_count * 2));

    size_t buf_idx = 0;

    // consolidate all the strings into a single array
    for (size_t i = 0; i < cvector_size(field_ref); i++)
    {
        const char *cur_name = field_ref[i];
        memcpy(buf + buf_idx, cur_name, strlen(cur_name));
        buf_idx += strlen(cur_name);

        // insert separator for all words except the last one*
        if (i != cvector_size(field_ref) - 1)
        {
            buf[buf_idx++] = '_';
        }
    }

    buf[buf_idx++] = '\0';

    return buf;
}

char *generate_native_field_accessor(cvector_vector_type(const char *) field_ref)
{
    // find out how long the total array is in terms of characters
    size_t char_count = 0;
    for (size_t i = 0; i < cvector_size(field_ref); i++)
    {
        const char *cur_name = field_ref[i];
        char_count += strlen(cur_name);
    }

    // allocate a buffer twice that big
    char *buf = (char *)malloc(char_count * 2);
    memset(buf, 0, (char_count * 2));

    size_t buf_idx = 0;

    // consolidate all the strings into a single array
    for (size_t i = 0; i < cvector_size(field_ref); i++)
    {
        const char *cur_name = field_ref[i];
        memcpy(buf + buf_idx, cur_name, strlen(cur_name));
        buf_idx += strlen(cur_name);

        if (i != cvector_size(field_ref) - 1)
        {
            buf[buf_idx++] = '.';
        }
    }

    buf[buf_idx++] = '\0';

    return buf;
}

/**
 * @brief Generates the source code for the ferry functions and writes it to the provided file handle.
 *
 * @param[in] fhand - Clang `CXType` object representing the relevant typedef.
 * @param[in] header_unit - Translation unit representing the header file to generate ferry functions from.
 */
void generate_ferry_source(FILE *fhand, const char *namespace)
{
    // NOTE: we can only use memcpy between constant arrays of base types since those do not
    // differ between native and serializable structs.

    // 1. Iterate over the parsed struct list.
    // 2. For each top-level struct we want to generate a single ferry function.
    // 3. Iterate over each field in the current parsed struct.
    // 4. If the field is some base type (integer, char, etc.), then we can do a simple assignment.
    // 5. If the field is a constant array of a base type (integer, char, etc.), then we can do a memcpy.
    // 6. If the field is an instance of a typedef'd struct, then we just call the function that
    //    ferries data for that particular type.
    // 7. If the field is a constant array (possibly multi-dimensional) of an
    //    instance of a typedef'd struct, then we need to call its ferry
    //    function multiple times (specifically the same number as the size of the array).

    // iterate over the parsed structs list
    for (size_t i = 0; i < cvector_size(parsed_struct_list); i++)
    {
        ParsedStruct cur_pstruct = parsed_struct_list[i];

        fprintf(sfile_hand, "void %s__sergen_ferry_%s(%s__Serializable%s *sstruct, %s *nstruct) { (void)(sstruct); (void)(nstruct); \n", namespace, cur_pstruct.name, namespace, cur_pstruct.name, cur_pstruct.name);

        // iterate over each field in the parsed struct
        for (size_t j = 0; j < cvector_size(cur_pstruct.field_vector); j++)
        {
            ParsedStructField cur_field           = cur_pstruct.field_vector[j];
            CXType            cur_field_type      = cur_field.type;
            const char       *cur_field_type_cstr = clang_getCString(clang_getTypeSpelling(cur_field_type));
            const char       *cur_field_name_cstr = clang_getCString(clang_getTypeSpelling(cur_field_type));
            CXType            base_field_type;
            long long         base_field_num;

            // cvector_vector_type(size_t) array_dim_sizes = NULL;
            int       array_dims = 0;
            long long array_len  = 1;

            char *native_accessor       = generate_native_field_accessor(cur_field.field_ref);
            char *serializable_accessor = generate_serializable_field_accessor(cur_field.field_ref);

            if (cur_field_type.kind == CXType_ConstantArray)
            {
                base_field_type = cur_field_type;
                // TODO: factor out into a function
                do
                {
                    base_field_num  = clang_getNumElements(base_field_type);
                    base_field_type = clang_getElementType(base_field_type);
                    array_dims++;
                    array_len *= base_field_num;
                } while (base_field_type.kind == CXType_ConstantArray);

                const char *base_field_type_name = clang_getCString(clang_getTypeSpelling(base_field_type));

                // case 1: derived type defined in user header
                if (check_user_typedef(base_field_type) && check_derived_type(base_field_type))
                {
                    // if it is, we can call the ferry function for each element in the constant array
                    fprintf(fhand, "    for (size_t i = 0; i < %lld; i++)\n", array_len);
                    fprintf(fhand, "    {\n");
                    fprintf(fhand, "        %s__sergen_ferry_%s(&((%s__Serializable%s *)sstruct->%s)[i], &((%s *)nstruct->%s)[i]);\n", namespace, base_field_type_name, namespace, base_field_type_name, serializable_accessor, base_field_type_name, native_accessor);
                    fprintf(fhand, "    }\n");
                }
                // case 2: derived type defined in system header
                else if (!check_user_typedef(base_field_type) && check_derived_type(base_field_type))
                {
                    fprintf(fhand, "        // WARNING: ferrying derived types from system headers is not supported\n");
                }
                // case 3 & 4: base type defined in user or system header
                else
                {
                    // memcpy since it is a constant array of a base type
                    fprintf(fhand, "    memcpy((void*)(&sstruct->%s), (void*)(&nstruct->%s), sizeof(nstruct->%s));\n", serializable_accessor, native_accessor, native_accessor);
                }
            }
            else if (cur_field_type.kind == CXType_Typedef)
            {
                CXType      canonical_type      = clang_getCanonicalType(cur_field_type);
                const char *canonical_type_cstr = clang_getCString(clang_getTypeSpelling(canonical_type));

                CXCursor         curs = clang_getTypeDeclaration(canonical_type);
                CXSourceLocation loc  = clang_getCursorLocation(curs);

                if (clang_Location_isInSystemHeader(loc))
                {
                    // case 1: type defined in system header, is a typedef of a struct or enum
                    // -> have no idea how to serialize something like this (not supported)
                    if (canonical_type.kind == CXType_Record || canonical_type.kind == CXType_Enum)
                    {
                        fprintf(fhand, "    // WARNING: unable to ferry a system header type since it cannot be serialized\n");
                    }
                    // case 2: type defined in system header, is a typedef of a base type (int, char, etc.)
                    // -> simple assignment in the ferry function
                    else
                    {
                        fprintf(fhand, "    sstruct->%s = nstruct->%s;\n", serializable_accessor, native_accessor);
                    }
                }
                else
                {
                    // case 3: defined in a user header, is a typedef of a struct or enum
                    // -> assume that we've already generated a ferry function for this type and call it
                    if (canonical_type.kind == CXType_Record || canonical_type.kind == CXType_Enum)
                    {
                        if (cur_pstruct.packed)
                        {
                            // NOTE: if we have a struct that is packed, we
                            // cannot simply take the address of any field
                            // inside it because that may result in unaligned
                            // pointer access which is UB. So, we must copy the
                            // relevant packed struct field and place it in an
                            // intermediate value (which is aligned) and then
                            // take the pointer to that.
                            fprintf(fhand, "    %s %s;\n", cur_field_type_cstr, serializable_accessor);
                            fprintf(fhand, "    %s = nstruct->%s;\n", serializable_accessor, native_accessor);

                            fprintf(fhand, "    %s__sergen_ferry_%s(&sstruct->%s, &%s);\n", namespace, cur_field_name_cstr, serializable_accessor, serializable_accessor);
                        }
                        else
                        {
                            fprintf(fhand, "    %s__sergen_ferry_%s(&sstruct->%s, &nstruct->%s);\n", namespace, cur_field_name_cstr, serializable_accessor, native_accessor);
                        }
                    }
                    // case 4: defined in a user header, is a typedef of a base type
                    // -> simple assignment in the ferry function
                    else
                    {
                        fprintf(fhand, "    sstruct->%s = nstruct->%s;\n", serializable_accessor, native_accessor);
                    }
                }
            }
            else
            {
                // consolidate the field name (we need to do this because of the need to flatten anonymous struct fields)
                // cvector_push_back(cur_field.field_ref, cur_field.name);
                fprintf(fhand, "    sstruct->%s = nstruct->%s;\n", serializable_accessor, native_accessor);
            }

            free(native_accessor);
            free(serializable_accessor);
        }

        fprintf(sfile_hand, "};\n\n");
    }

    // iterate over the parsed enums list
    for (size_t i = 0; i < cvector_size(parsed_enum_list); i++)
    {
        // for each enum we want to generate the source code for the ferry function
        ParsedEnum cur_penum = parsed_enum_list[i];

        fprintf(sfile_hand, "void %s__sergen_ferry_%s(%s__Serializable%s *senum, %s *nenum) {\n", namespace, cur_penum.name, namespace, cur_penum.name, cur_penum.name);
        fprintf(sfile_hand, "    switch (*nenum) {\n");

        // keep track of seen values
        cvector_vector_type(int) seen_values = NULL;

        // iterate over each field and its value
        for (size_t j = 0; j < cvector_size(cur_penum.enum_field_vector); j++)
        {
            ParsedEnumField cur_penum_field = cur_penum.enum_field_vector[j];

            /* Check if we've seen the current field's value before and if we
             * have then skip generating the case statement for it. */
            if (find_in_vector(seen_values, cur_penum_field.id))
            {
                continue;
            }

            fprintf(sfile_hand, "        case %s:\n", cur_penum_field.name);
            fprintf(sfile_hand, "        {\n");
            fprintf(sfile_hand, "            senum->label = \"%s\";\n", cur_penum_field.name);
            fprintf(sfile_hand, "            senum->id = %d;\n", cur_penum_field.id);
            fprintf(sfile_hand, "            break;\n");
            fprintf(sfile_hand, "        }\n");
            cvector_push_back(seen_values, cur_penum_field.id);
        }

        fprintf(sfile_hand, "        default: senum->label = \"INVALID\";\n");

        fprintf(sfile_hand, "    }\n");
        fprintf(sfile_hand, "}\n\n");
    }
}

bool find_in_vector(cvector_vector_type(int) vec, int item)
{
    int *it = NULL;
    cvector_for_each_in(it, vec)
    {
        if (*it == item)
        {
            return true;
        }
    }
    return false;
}

/**
 * @brief Generates the source code for the JSON pack functions and writes it to the provided file handle.
 *
 * @param[in] fhand - Clang `CXType` object representing the relevant typedef.
 * This file handle must be valid and open.
 */
void generate_pack_source(const char *header_file_path, const char *namespace)
{
    CXTranslationUnit unit;
    enum CXErrorCode  rc = clang_parseTranslationUnit2(libclang_index, header_file_path, NULL, 0, NULL, 0, 0, &unit);
    if (rc != CXError_Success)
    {
        printf("[SERGEN]: error, unable to parse following header file: %s\n", header_file_path);
        return;
    }

    CXCursor cursor = clang_getTranslationUnitCursor(unit);

    // use this to collect all typedef cursors (these can be typedefs for enums, structs, unions, etc.)
    clang_visitChildren(cursor, stage_two_base_visitor, (CXClientData)(namespace));

    // iterate over each field of the parsed structs and record their fields
    for (size_t i = 0; i < cvector_size(record_list); i++)
    {
        CXType      typedef_cursor_type      = clang_getCursorType(record_list[i]);
        const char *typedef_cursor_type_cstr = clang_getCString(clang_getTypeSpelling(typedef_cursor_type));

        CXType      canonical_type      = clang_getCanonicalType(typedef_cursor_type);
        const char *canonical_type_cstr = clang_getCString(clang_getTypeSpelling(typedef_cursor_type));

        if (canonical_type.kind != CXType_Record)
        {
            continue;
        }

        // field vector will be filled out by the field visitor function
        ParsedStruct parsed_struct = {.name = canonical_type_cstr, .field_vector = NULL};

        clang_Type_visitFields(canonical_type, stage_two_field_visitor, &parsed_struct);

        // printf("INFO: Inserting into parsed struct list, struct: %s!\n", parsed_struct.name);

        // now we have a valid parsed struct instance, add it to the list so it can be used later
        cvector_push_back(parsed_struct_list, parsed_struct);
    }

    // iterate over each parsed struct and generate the packing function for each one
    for (size_t i = 0; i < cvector_size(parsed_struct_list); i++)
    {
        ParsedStruct cur_struct = parsed_struct_list[i];
        fprintf(sfile_hand, "json_t *%s__sergen_pack_%s(%s *sstruct, JsonPackResult_e *result) {\n", namespace, cur_struct.name, cur_struct.name);

        // printf("INFO: Generating pack function for struct: %s!\n", cur_struct.name);

        // step 1: generate the local variables
        fprintf(sfile_hand, "    json_error_t error;\n");
        fprintf(sfile_hand, "    json_t *out = NULL;\n");
        fprintf(sfile_hand, "    json_t *list = NULL;\n");
        fprintf(sfile_hand, "    size_t flags = 0;\n");

        // step 2: generate the Jansson string
        fprintf(sfile_hand, "    const char *json_fmt = \"{");

        cvector_vector_type(ParsedStructField) serializable_fields = NULL;
        cvector_vector_type(ParsedStructField) array_fields        = NULL;

        for (size_t f = 0; f < cvector_size(cur_struct.field_vector); f++)
        {
            ParsedStructField cur_field = cur_struct.field_vector[f];
            const char       *type_name = clang_getCString(clang_getTypeSpelling(cur_field.type));

            switch (cur_field.type.kind)
            {
                case CXType_Bool:
                    {
                        fprintf(sfile_hand, "sb");
                        cvector_push_back(serializable_fields, cur_field);
                        break;
                    }

                case CXType_Typedef:
                    {
                        CXType canon_type = clang_getCanonicalType(cur_field.type);

                        char buf[128] = {0};
                        snprintf(buf, 128, "%s__Serializable", namespace);

                        if (check_typedef_start(cur_field.type, buf))
                        {
                            fprintf(sfile_hand, "so?");
                            cur_field.complex_type = true;
                            cvector_push_back(serializable_fields, cur_field);
                        }
                        /* If we have a integral typedef, then serialize it differently. */
                        else if (is_integral_type(canon_type) && clang_Type_getSizeOf(canon_type) <= MAX_SERIALIZABLE_INTEGRAL_SIZE)
                        {
                            fprintf(sfile_hand, "sI");
                            cvector_push_back(serializable_fields, cur_field);
                        }
                        else
                        {
                            printf("WARNING [CXType_Typedef]: cannot pack field %s in struct %s!\n", cur_field.name, cur_struct.name);
                        }
                        break;
                    }

                case CXType_ConstantArray:
                    {
                        CXType          base_type      = get_const_array_base_type(cur_field.type);
                        enum CXTypeKind base_type_kind = base_type.kind;

                        if (base_type_kind == CXType_Char_S)
                        {
                            fprintf(sfile_hand, "ss?");
                            cvector_push_back(serializable_fields, cur_field);
                        }
                        else
                        {
                            fprintf(sfile_hand, "s[o*]");
                            cvector_push_back(serializable_fields, cur_field);
                            cvector_push_back(array_fields, cur_field);
                        }
                        break;
                    }

                // could point to a string?
                case CXType_Pointer:
                    {
                        CXType pointee_type = clang_getPointeeType(cur_field.type);
                        if (pointee_type.kind == CXType_Char_S)
                        {
                            fprintf(sfile_hand, "ss?");
                            cvector_push_back(serializable_fields, cur_field);
                            break;
                        }
                        printf("WARNING [CXType_Pointer]: cannot pack field %s in struct %s!\n", cur_field.name, cur_struct.name);
                        break;
                    }

                case CXType_Char_U ... CXType_LongLong:
                    {
                        fprintf(sfile_hand, "sI");
                        cvector_push_back(serializable_fields, cur_field);
                        break;
                    }

                case CXType_Float ... CXType_Double:
                    {
                        fprintf(sfile_hand, "sf");
                        cvector_push_back(serializable_fields, cur_field);
                        break;
                    }

                default:
                    {
                        // basically do nothing?
                        // this shouldn't ever happen technically
                        printf("WARNING [default]: cannot pack field \"%s\" (type: %s, num: %d) in struct %s!\n", cur_field.name, type_name, cur_field.type.kind, cur_struct.name);
                        break;
                    }
            }
        }

        fprintf(sfile_hand, "}\";\n\n");

        // step 3: generate the `json_pack_ex` call and calls to other pack functions if necessary

        if (cvector_size(serializable_fields) > 0)
        {
            fprintf(sfile_hand, "    out = json_pack_ex(\n");
            fprintf(sfile_hand, "        &error,\n");
            fprintf(sfile_hand, "        flags,\n");
            fprintf(sfile_hand, "        json_fmt,\n");

            for (size_t f = 0; f < cvector_size(serializable_fields); f++)
            {
                ParsedStructField cur_field = serializable_fields[f];
                fprintf(sfile_hand, "        \"%s\",\n", cur_field.name);

                bool is_serializable_integral_typedef = is_integral_type(clang_getCanonicalType(cur_field.type)) && clang_Type_getSizeOf(cur_field.type) <= MAX_SERIALIZABLE_INTEGRAL_SIZE;

                // if the type is another struct, then call the pack function for that type
                if (cur_field.complex_type)
                {
                    const char *field_type_name = clang_getCString(clang_getTypeSpelling(cur_field.type));
                    fprintf(sfile_hand, "        %s__sergen_pack_%s(&sstruct->%s, NULL)", namespace, field_type_name, cur_field.name);
                }
                else if (cur_field.type.kind == CXType_ConstantArray)
                {
                    CXType          base_type      = get_const_array_base_type(cur_field.type);
                    enum CXTypeKind base_type_kind = base_type.kind;

                    // if we have a char array, then treat it like a string
                    if (base_type_kind == CXType_Char_S)
                    {
                        fprintf(sfile_hand, "        (const char *)(sstruct->%s)", cur_field.name);
                    }
                    else
                    {
                        // non-character arrays are filled out later on
                        fprintf(sfile_hand, "        NULL");
                    }
                }
                /* If the type is an integral type or a typedef of an integral type... */
                else if (is_integral_type(cur_field.type) || is_serializable_integral_typedef)
                {
                    fprintf(sfile_hand, "        (json_int_t)sstruct->%s", cur_field.name);
                }
                else
                {
                    fprintf(sfile_hand, "        sstruct->%s", cur_field.name);
                }

                // skip comma for the last argument
                if (f == cvector_size(serializable_fields) - 1)
                {
                    fprintf(sfile_hand, "\n");
                }
                else
                {
                    fprintf(sfile_hand, ",\n");
                }
            }

            fprintf(sfile_hand, "    );\n\n");
        }

        for (size_t i = 0; i < cvector_size(array_fields); i++)
        {
            ParsedStructField cur_field = array_fields[i];

            // get the array from the main JSON object
            fprintf(sfile_hand, "    list = json_object_get(out, \"%s\");\n", cur_field.name);
            int       array_dims = 0;
            long long array_len  = 1;

            CXType    base_field_type = cur_field.type;
            long long base_field_num  = 0;
            do
            {
                base_field_num  = clang_getNumElements(base_field_type);
                base_field_type = clang_getElementType(base_field_type);
                array_dims++;
                array_len *= base_field_num;
            } while (base_field_type.kind == CXType_ConstantArray);

            const char *base_field_type_spell_cstr = clang_getCString(clang_getTypeSpelling(base_field_type));

            // now that we have the array length we can iterate over each element in the array and
            // add it to the JSON array

            fprintf(sfile_hand, "    for (size_t i = 0; i < %lld; i++)\n", array_len);
            fprintf(sfile_hand, "    {\n");

            // depending on the base field type, we do something different...

            // if it's a serializable type, call the corresponding pack function for it...
            char buf[128] = {0};
            snprintf(buf, 128, "%s__Serializable", namespace);
            if (check_typedef_start(base_field_type, buf))
            {
                fprintf(sfile_hand, "        json_t *elem = %s__sergen_pack_%s(&((%s *)sstruct->%s)[i], NULL);\n", namespace, base_field_type_spell_cstr, base_field_type_spell_cstr, cur_field.name);
                fprintf(sfile_hand, "        json_array_append_new(list, elem);\n");
            }
            else
            {
                // in this case, the base type can be a float, integer, boolean, or string
                fprintf(sfile_hand, "        \n");
                switch (base_field_type.kind)
                {
                    case CXType_Bool:
                        {
                            fprintf(sfile_hand, "        json_t *elem = json_boolean( (bool)(sstruct->%s[i]) );\n", cur_field.name);
                            break;
                        }
                    case CXType_Char_U ... CXType_LongLong:
                        {
                            fprintf(sfile_hand, "        json_t *elem = json_integer( (json_int_t)( ((%s *)sstruct->%s)[i] ) );\n", base_field_type_spell_cstr, cur_field.name);
                            break;
                        }
                    case CXType_Float ... CXType_Double:
                        {

                            fprintf(sfile_hand, "        json_t *elem = json_real( ((%s *)sstruct->%s)[i] );\n", base_field_type_spell_cstr, cur_field.name);
                            break;
                        }
                    case CXType_Pointer:
                        {
                            CXType pointee_type = clang_getPointeeType(cur_field.type);
                            if (pointee_type.kind == CXType_Char_S)
                            {
                                fprintf(sfile_hand, "        json_t *elem = json_string( ((const char *)sstruct->%s)[i] );\n", cur_field.name);
                            }
                            else
                            {
                                fprintf(sfile_hand, "        json_t *elem = NULL;\n");
                            }
                            break;
                        }
                    case CXType_Typedef:
                        {
                            CXType    canonical_type = clang_getCanonicalType(base_field_type);
                            long long type_size      = clang_Type_getSizeOf(base_field_type);
                            /* If the canonical type is integral (stdint.h
                             * types) and the size is less than or equal to 64,
                             * then we serialize accordingly */
                            if (is_integral_type(canonical_type) && type_size <= MAX_SERIALIZABLE_INTEGRAL_SIZE)
                            {
                                fprintf(sfile_hand, "        json_t *elem = json_integer( (json_int_t)( ((%s *)sstruct->%s)[i] ) );\n", base_field_type_spell_cstr, cur_field.name);
                            }
                            else
                            {
                                fprintf(sfile_hand, "        json_t *elem = NULL;\n");
                            }
                            break;
                        }
                    default:
                        fprintf(sfile_hand, "        json_t *elem = NULL;\n");
                }

                fprintf(sfile_hand, "        json_array_append_new(list, elem);\n");
            }

            fprintf(sfile_hand, "    }\n\n");
        }

        // step 4: generate the error check

        fprintf(sfile_hand, "    if (result != NULL)\n");
        fprintf(sfile_hand, "    {\n");
        fprintf(sfile_hand, "        if (out == NULL)\n");
        fprintf(sfile_hand, "        {\n");
        fprintf(sfile_hand, "            *result = PACK_ERROR;\n");
        fprintf(sfile_hand, "        }\n");
        fprintf(sfile_hand, "        else\n");
        fprintf(sfile_hand, "        {\n");
        fprintf(sfile_hand, "            *result = PACK_SUCCESS;\n");
        fprintf(sfile_hand, "        }\n");
        fprintf(sfile_hand, "    }\n\n");

        // step 5: generate

        fprintf(sfile_hand, "    return out;\n");
        fprintf(sfile_hand, "}\n\n");
    }

    // dispose of the translation unit and index
    clang_disposeTranslationUnit(unit);
}

bool is_integral_type(CXType type)
{
    switch (type.kind)
    {
        case CXType_Char_U ... CXType_LongLong:
            return true;
        default:
            return false;
    }
    return false;
}

void generate_header_file(CXTranslationUnit unit, const char *namespace)
{
    CXCursor cursor = clang_getTranslationUnitCursor(unit);

    // use this to collect all typedef cursors (these can be typedefs for enums, structs, unions, etc.)
    clang_visitChildren(cursor, base_visitor, NULL);

    // convert each `typedef enum` declaraction into its serialized format
    for (size_t i = 0; i < cvector_size(enum_list); i++)
    {
        CXCursor    cur_cursor      = enum_list[i];
        CXType      cur_cursor_type = clang_getCursorType(cur_cursor);
        const char *typedef_name    = clang_getCString(clang_getTypeSpelling(cur_cursor_type));

        // QUESTION: does `typedef_name` stay in scope? Yes, because the recursive call stack frame's
        // lifetime is smaller than the current call's stack frame.
        EnumFieldVisitorData enum_visitor_data = {
            .parsed_enum = {.name = typedef_name, .enum_field_vector = NULL},
            .annotated   = false,
        };
        clang_visitChildren(cur_cursor, enum_field_visitor, &enum_visitor_data);

        // after this point we should have a filled out parsed enum struct
        cvector_push_back(parsed_enum_list, enum_visitor_data.parsed_enum);

        // printf("* %s\n", typedef_name);

        fprintf(hfile_hand, "// ========= `%s` generated types ==========\n\n", typedef_name);

        // generate the typedef for the serializable enum
        fprintf(hfile_hand, "typedef struct {\n");
        fprintf(hfile_hand, "    const char *label;\n");
        fprintf(hfile_hand, "    long id;\n");
        fprintf(hfile_hand, "} %s__Serializable%s;\n\n", namespace, typedef_name);

        // generate the packing function prototype
        fprintf(hfile_hand, "json_t *%s__sergen_pack_%s__Serializable%s(%s__Serializable%s *sstruct, JsonPackResult_e *error);\n", namespace, namespace, typedef_name, namespace, typedef_name);
        fprintf(hfile_hand, "void %s__sergen_ferry_%s(%s__Serializable%s *sstruct, %s *nstruct);\n\n", namespace, typedef_name, namespace, typedef_name, typedef_name);

        fprintf(hfile_hand, "// ========================================\n\n");
    }

    // convert each `typedef struct` declaraction into its serialized format
    for (size_t i = 0; i < cvector_size(record_list); i++)
    {
        CXType      typedef_cursor_type      = clang_getCursorType(record_list[i]);
        const char *typedef_cursor_type_cstr = clang_getCString(clang_getTypeSpelling(typedef_cursor_type));

        CXType      canonical_type      = clang_getCanonicalType(typedef_cursor_type);
        const char *canonical_type_cstr = clang_getCString(clang_getTypeSpelling(typedef_cursor_type));

        CXCursor record_cursor = clang_getTypeDeclaration(canonical_type);

        if (canonical_type.kind != CXType_Record)
        {
            continue;
        }

        // check if the relevant struct is packed or not
        bool packed = false;
        clang_visitChildren(record_cursor, struct_packed_visitor, (CXClientData)(&packed));

        // field vector will be filled out by the field visitor function
        ParsedStruct parsed_struct = {.name = canonical_type_cstr, .field_vector = NULL, .packed = packed};

        // printf("* %s\n", typedef_cursor_type_cstr);

        fprintf(hfile_hand, "// ========= `%s` generated types ==========\n\n", typedef_cursor_type_cstr);

        // insert the struct header here
        fprintf(hfile_hand, "typedef struct {\n");

        // this function expects to get a `CXType` object with kind=`CXType_Record`
        FieldVisitorData client = {.pstruct = &parsed_struct, .is_anonymous = true, .namespace = namespace};
        clang_Type_visitFields(canonical_type, field_visitor, &client);

        fprintf(hfile_hand, "} %s__Serializable%s;\n\n", namespace, typedef_cursor_type_cstr);

        // generate the packing function prototype
        fprintf(hfile_hand, "json_t *%s__sergen_pack_%s__Serializable%s(%s__Serializable%s *sstruct, JsonPackResult_e *error);\n", namespace, namespace, typedef_cursor_type_cstr, namespace, typedef_cursor_type_cstr);
        fprintf(hfile_hand, "void %s__sergen_ferry_%s(%s__Serializable%s *sstruct, %s *nstruct);\n\n", namespace, typedef_cursor_type_cstr, namespace, typedef_cursor_type_cstr, typedef_cursor_type_cstr);

        fprintf(hfile_hand, "// ========================================\n\n\n");

        // now we have a valid parsed struct instance, add it to the list so it can be used later
        cvector_push_back(parsed_struct_list, parsed_struct);
    }
}
